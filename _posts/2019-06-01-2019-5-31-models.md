---
title: Synchrony, Asynchrony and Partial synchrony
date: 2019-06-01 15:00:00 -04:00
tags:
- dist101
- models
author: Ittai Abraham
layout: post
---

In the standard distributed computing model, communication uncertainty is modeled by an **adversary** that controls message delays. The **communication model** defines the limits to the power of the adversary to delay messages. 

There are three basic models: synchronous, asynchronous, and partial synchrony.


In the **Synchronous model**, there exists some known finite time bound $\Delta$. For any message sent, the adversary can delay its delivery by at most $\Delta$.

In the **Asynchronous model**, for any message sent, the adversary can delay its delivery by any finite amount of time. There is no delivery bound, but every message must eventually be delivered.

The **Partial synchrony model** (see [DLS88](https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf)) aims to find a middle ground between these two models. The assumption is that there exists some known finite time bound $\Delta$ and a special event called GST (Global Stabilization Time) such that:
* The adversary must cause the GST event to eventually happen after some unknown finite time. 
* Any message sent at time $x$ must be delivered by time $\Delta + \max \(x,GST\)$.

Informally, the system behaves asynchronously until GST and synchronously afterward. Note that the adversary can delay the GST event by any finite amount of time and that no protocol can explicitly detect that GST has occurred. There is no external signal that tells you that GST happened.

At first thought, the Synchronous model may seem to be good enough. Why not just assume, for example, that any message sent over the internet will be delivered by say 2 minutes? First, there is a trade-off:
* Setting a large and conservative $\Delta$ of say 10 minutes may indeed always faithfully model the real world. However, protocol designers who depend on $\Delta$ may incur very long timeouts and hence degrade performance.
* Setting a small, aggressive $\Delta$ (e.g., 0.1s) may not always match the real world. This means that protocols whose safety depends on this bound may suffer safety violations in the real world.

Second, even if you think you found a magical sweet spot for $\Delta$, imagine a sender that broadcasts a message to two receivers, one message arrives after $\Delta - \epsilon$ time and the other after $\Delta + \epsilon$. Here the real world would behave differently than the model and this could again potentially cause safety problems.

To overcome the problems with synchrony, the asynchronous model forces protocol designers to assume nothing about network delays. The result is often robust protocols: 
* Since they do not depend on any time bound, message delays cannot cause unexpected safety violations.
* Since they cannot use any fixed values for timeouts, they must inherently adapt to the actual latency of the system.

The main problem with the asynchronous model is that protocols in this model tend to be more complex and harder to reason about. Moreover, there are many known complexity gaps between synchrony and asynchrony. Two examples:
* The celebrated [Fischer, Lynch and Paterson 1985](https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf) lower bound says that in the asynchronous model, any protocol that solves consensus withstanding an adversary (who can fail-stop just one party) must have an infinite execution (see this [blog post](https://decentralizedthoughts.github.io/2019-12-15-asynchrony-uncommitted-lower-bound/)).
* Authenticated Byzantine Agreement is possible for $n>2f$ in the synchronous model (see [blog post](https://decentralizedthoughts.github.io/2019-11-11-authenticated-synchronous-bft/)) but not possible for $n \leq 3f$ in the asynchronous model (where $f$ is the number of parties the adversary can corrupt). See this [blog post](https://decentralizedthoughts.github.io/2019-06-25-on-the-impossibility-of-byzantine-agreement-for-n-equals-3f-in-partial-synchrony/) for the lower bound.

The Partial synchrony model was suggested in 1988 by [Dwork, Lynch, and Stockmeyer](https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf) (with a [preliminary version](http://groups.csail.mit.edu/tds/papers/Lynch/podc84-DLS.pdf) in PODC 1984). Their paper **"Consensus in the presence of partial synchrony"** was [awarded]((https://eatcs.org/index.php/dijkstra-prize/605)) the Edsger W. Dijkstra Prize in Distributed Computing in 2007.  This Partial synchrony model is also (implicitly) used in two other publications from around the same time:  Lamport's [Paxos](https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf) and Oki and Liskov's [viewstamped replication](https://dl.acm.org/citation.cfm?id=62549).


Partial synchrony captures the idea of designing protocols for systems that are usually synchronous but tolerate temporary violations (e.g., denial-of-service attacks). In particular, a recurring theme in the Partial synchrony model is to design protocols that are always _safe_ (even when the system is asynchronous) but provide _liveness_ and _termination_ guarantees only after GST (only when the system is synchronous). 


Many large-scale systems use protocols that can be successfully reasoned about in the Partial Synchrony model. Some examples of such systems: [Zookeeper](https://zookeeper.apache.org/), [etcd](https://github.com/etcd-io/etcd), [Spanner](https://cloud.google.com/spanner/), [Cosmos Hub](https://hub.cosmos.network/).

An alternative definition for Partial synchrony is to assume that there is some finite **unknown** upper bound $\Delta$ on message delivery. This bound is not known in advance and can be chosen by the adversary. See [this follow-up post](https://decentralizedthoughts.github.io/2019-09-13-flavours-of-partial-synchrony/) or [DLS88](https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf) for this and for the equivalence of these definitions.

## Acknowledgments
Special thanks to [Alin Tomescu](http://twitter.com/alinush407) and [Kai Mast](https://kai-mast.de/) for reviewing this post and sending insightful comments. 
Please leave comments on [Twitter](https://twitter.com/ittaia/status/1140328864788504581?s=20)

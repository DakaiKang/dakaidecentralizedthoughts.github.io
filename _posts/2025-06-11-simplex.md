---
title: From Tendermint to Simplex
date: 2025-06-11 00:00:00 -04:00
published: false
tags:
- dist101
- consensus
- BFT
author: Ling Ren
---

[Simplex](https://simplex.blog/) is a partially synchronous Byzantine Fault Tolerant (BFT) protocol designed by Ben Chan and Rafael Pass in 2023. It has recently been adopted by [Solana](https://solana.com/). 

Simplex is a simple and clean BFT protocol. Ben did a great job explaining it [from scratch](https://simplex.blog/). But if you are like me as someone already familiar with other BFT protocols such as PBFT or Tendermint, you may wonder how Simplex differs and what its core innovation is. This post is my attempt at understanding Simplex in relation to Tendermint. 

For simplicity, I will focus on single-shot consensus, i.e., agreeing on a single value. I will modify Tendermint into Simplex through a sequence of changes. I should clarify that this is most likely not the chain of thoughts that Ben and Rafael went through when designing Simplex. But this journal is helpful (at least for me) in understanding the key idea in Simplex. 

Here is the single-shot Tendermint protocol, with a minor optimization from [HotStuff-2](https://eprint.iacr.org/2023/397.pdf). . The protocol proceeds in views starting from view 1. Each view has a designated leader. All messages are signed and sent to all. Let &Delta; be the message delay upper bound after GST. 

The protocol uses the standard techniques of certificates (cert for short) and cert ranking by views. A certificate Cert(k, x) is a collection of n-f votes from view k for value x. For convenience, we can think of an empty string to be Cert(0, x) for any x. 

----------------
Upon entering view k: <br>
    Everyone starts a local timer T <br>
    Everyone sends the highest Cert seen <br>
    Leader waits for 2&Delta; time or Cert(k-1, *) <br>
    Leader sends (Propose, k, x, Cert(k’, x)) for the highest k’ <br>
    
Upon receiving (Propose, k, x, Cert(k’, x)) and T < 5&Delta; <br>
    Send (Vote, k, x) if not having seen a higher Cert <br>
        
Upon receiving n-f (Vote, k, x) and T < 5&Delta; 	// Denote them Cert(k, x) <br>
    Send (Finalize, x, k) <br>

Upon receiving n-f (Finalize, k, x) <br>
    Decide x <br>
    Forward these n-f messages <br>
    Terminate <br>
    
Upon T = 5&Delta; <br>
    Send (View-change, k) <br>

Upon receiving n-f (View-change, k) <br>
    Forward these n-f messages <br>
    Enter view k+1 
    
----------------

At a high level, each view has four steps: (1) everyone sends the highest cert it has seen, (2) leader reproposes the value in the highest cert, (3) everyone votes if it has not seen a cert higher than the one in leader's proposal, (4) another round of voting to finalize the decision. 

The main innovation of Tendermint is: a party refuses to vote for the leader if it has seen a higher cert than the one in the leader's proposal. This ensures safety. Here is a quick proof. Suppose one party decides x in view k. Then, n-f parties have seen Cert(k, x), out of which n-2f are honest. They will refuse to vote any x' != x in the next view. Thus, at most f honest and f Byzantine would vote for x' != x. But 2f < n-f, so Cert(k+1, x') cannot form. Safety holds by induction.  

This design choice necessitates another crucial step in Tendermint: the leader needs to wait for 2&Delta; time before proposing. This is important because we need an honest leader post-GST to receive __every__ honest party's reported cert. Otherwise, it is possible that some honest party p holds a cert that the honest leader is unware of. Then p will refuse to vote for the honest leader, breaking liveness. The wait is set to 2&Delta; because post-GST, a party may enter the view up to &Delta; later than the leader and it takes up to &Delta; time for its cert to reach the leader. 

That also explains why the view-change timeout is 5&Delta;: 2&Delta; wait plus &Delta; delay for each of the three messages (Propose, Vote, Finalize). 

Note that I have incorporated a trick from [HotStuff-2](https://eprint.iacr.org/2023/397.pdf). The leader can skip the 2&Delta; wait once it receives a cert from the last view. The cert from the last view is guaranteed to be the highest at this point, so it convinces all honest parties to vote. With this trick, the protocol is optimistically responsive, which means the protocol proceeds at the actual speed of the network if all parties are honest. 

Now we are ready to modify the protocol into Simplex. I have marked the changes in bold with numbered notes.

----------------
Upon entering view k: <br>
    Everyone starts a local timer T <br>
    Everyone sends the highest Cert seen <br>
    Leader waits for 2&Delta; time or Cert(k-1, *) <br>
    Leader sends (Propose, k, x, Cert(k’, x)) for the highest k’ <br>
    
Upon receiving (Propose, k, x, Cert(k’, x)) and T < 5&Delta; <br>
    Send (Vote, k, x) if not having seen a higher Cert <br>
        
Upon receiving n-f (Vote, k, x) and T < 5&Delta;      // Denote them Cert(k, x) <br>
    Send (Finalize, x, k) <br>
    **Cancel timer T**        // Change #1 

Upon receiving n-f (Finalize, k, x) <br>
    Decide x <br>
    Forward these n-f messages <br>
    Terminate <br>
    
Upon T = 5&Delta; <br>
    Send (View-change, k) <br>

Upon receiving n-f (View-change, k) **or Cert(k, *) **      // Change #2 <br>
    Forward these n-f messages <br>
    Enter view k+1 
    
----------------


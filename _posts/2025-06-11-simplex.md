---
title: From Tendermint to Simplex
date: 2025-06-11 00:00:00 -04:00
published: false
tags:
- dist101
- consensus
- BFT
author: Ling Ren
---

[Simplex](https://simplex.blog/) is a partially synchronous Byzantine Fault Tolerant (BFT) protocol designed by Ben Chan and Rafael Pass in 2023. It has recently been adopted by [Solana](https://solana.com/). 

Simplex is a simple and clean BFT protocol. Ben did a great job explaining it [from scratch](https://simplex.blog/). But if you are like me as someone already familiar with other BFT protocols such as PBFT or Tendermint, you may wonder how Simplex differs and what its core innovation is. This post is my attempt at understanding Simplex in relation to Tendermint. 

For simplicity, I will focus on single-shot consensus, i.e., agreeing on a single value. I will modify Tendermint into Simplex through a sequence of changes. I should clarify that this is most likely not the chain of thoughts that Ben and Rafael went through when designing Simplex. But this journal is helpful (at least for me) in understanding the key idea in Simplex. 

Here is the single-shot Tendermint protocol, with a minor optimization from [HotStuff-2](https://eprint.iacr.org/2023/397.pdf). The protocol proceeds in views starting from view 1. Each view has a designated leader. Let &Delta; be the message delay upper bound after GST. All messages are signed and sent to all. The protocol uses the standard techniques of certificates (cert for short) and cert ranking by views. A certificate Cert(k, x) is a collection of n-f votes from view k for value x. For convenience, we think of an empty string as Cert(0, x) for any x. 

----------------
Upon entering view k: <br>
    Everyone starts a local timer T <br>
    Everyone sends the highest Cert seen <br>
    Leader waits for 2&Delta; time or Cert(k-1, *) <br>
    Leader sends (Propose, k, x, Cert(k’, x)) for the highest k’ <br>
    
Upon receiving (Propose, k, x, Cert(k’, x)) in view k <br>
    Send (Vote, k, x) if not having seen a higher Cert <br>
        
Upon receiving n-f (Vote, k, x) in view k 	// Denote them Cert(k, x) <br>
    Send (Finalize, x, k) <br>

Upon receiving n-f (Finalize, k, x) <br>
    Decide x <br>
    Forward these messages <br>
    Terminate <br>
    
Upon T = 5&Delta; in view k <br>
    Send (View-change, k) <br>

Upon receiving n-f (View-change, k) <br>
    Forward these messages <br>
    Enter view k+1 
    
----------------

Here are some main takeaways from the Tendermint protocol. First, the main innovation of Tendermint is that a party refuses to vote if it has seen a higher cert than the one in the leader's proposal. This ensures safety. Here is a proof sketch. Suppose one party decides x in view k. Then, n-2f honest parties have seen Cert(k, x). They will refuse to vote for any x' != x in the next view, so Cert(k+1, x') cannot form. Safety holds by induction.  

Second, the above design necessitates a crucial step in Tendermint: the leader needs to wait for 2&Delta; time before proposing. This is because we need an honest leader post-GST to receive __every__ honest party's reported cert. Otherwise, it is possible that some honest party p holds a high cert that the honest leader is unware of. Then, p will refuse to vote for the honest leader, breaking liveness. The wait is set to 2&Delta; because post-GST, a party may enter the view up to &Delta; later than the leader and it takes up to &Delta; time for its cert to reach the leader. 

That also explains why the view-change timeout is 5&Delta;: 2&Delta; wait plus &Delta; delay for each of the three messages (Propose, Vote, Finalize). If a party does not decide within 5&Delta;, it requests a view-change. Upon receiving sufficient view-change requests, a party enters a new view.

Lastly, I have incorporated a trick from [HotStuff-2](https://eprint.iacr.org/2023/397.pdf). The leader can skip the 2&Delta; wait once it receives a cert from the last view, because it is guaranteed to be the highest cert so far. With this trick, the protocol is optimistically responsive, i.e., proceeds at the actual speed of the network if all parties are honest. 

We are now ready to modify the protocol into Simplex. I have marked the changes in bold with numbered notes.

----------------
Upon entering view k: <br>
    Everyone starts a local timer T <br>
    <del>Everyone sends the highest Cert seen</del> <br>
    <del>Leader waits for 2&Delta; time or Cert(k-1, *) </del>      // Change #4 <br>
    Leader sends (Propose, k, x, Cert(k’, x)) for the highest k’ <br>
    
Upon receiving (Propose, k, x, Cert(k’, x)) in view k <br>
    Send (Vote, k, x) if having seen n-f (View-change, l) for all k' < l < k      // Change #2 <br>
        
Upon receiving n-f (Vote, k, x) in view k      // Denote them Cert(k, x) <br>
    Send (Finalize, x, k) <br>
    **Cancel timer T**        // Change #1 <br>
    **Forward Cert(k, x) and enter view k+1**        // Change #3 <br>

Upon receiving n-f (Finalize, k, x) <br>
    Decide x <br>
    Forward these messages <br>
    Terminate <br>
    
Upon **T = 3&Delta;** in view k     // Change #5 <br>
    Send (View-change, k) <br>

Upon receiving n-f (View-change, k) <br>
    Forward these messages <br>
    Enter view k+1 
    
----------------

The key innovation of Simplex is Change #1 and #2. When an honest party sends Finalize in view k, it will cancel its timer T for this view so that it will never send (View-change, k). Note also that if an honest party sends (View-change, k), it exits view k and will never send (Finalize, k, *). By a standard quorum intersection argument, this means n-f (View-change, k) and n-f (Finalize, k, *) are mutually exclusive! This property is __very__ interesting and is unique to Simplex to the best of my knowledge. 

In particular, this property enables Change #2. An honest party will vote for the leader's proposal as long as it has seen n-f View-change for every view higher than the leader's cert, __even if__ it has a higher cert. This behavior would be unsafe in Tendermint. It is safe in Simplex because the existence of n-f View-change for a given view is proof that no decision occurred in that view. 

Changes #3, #4, and #5 are just natural consequences of the previous two changes. Because honest parties that sent Finalize can no longer send View-change, we need a second way to move to a higher view (#3). Since an undetected higher cert no longer breaks liveness, the leader no longer needs the 2&Delta; wait before proposing (#4). Once we get rid of the 2&Delta; wait, the view-change timeout can be reduced from 5&Delta; to 3&Delta; (#5). 

We have now arrived at the single-shot Simplex protocol. 

What improvement does Simplex achieve? In the good case (honest leader post-GST), the behavior of Simplex is actually exactly the same as Tendermint with the HotStuff-2 trick (which can also be viewed as HotStuff-2 with all-to-all voting): the protocol commits in 3 rounds at network speed (optimistically responsive). When we have a faulty leader post-GST, Simplex has an advantage: every failed view lasts 3&Delta; instead of 5&Delta;, so it gets to an honest leader sooner.  



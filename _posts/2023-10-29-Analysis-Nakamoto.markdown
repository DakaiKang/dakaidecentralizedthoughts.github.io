---
title: Simpler Security proof for Nakamoto Consensus
date: 2023-10-29 22:55:00 -08:00
tags:
- blockchain101
author: Ling Ren
---

Four years ago (time flies!), I made a post on a [simple security proof for Nakamoto consensus](https://decentralizedthoughts.github.io/2019-11-29-Analysis-Nakamoto/). While the proof intuition, as outlined in that post, is still reasonably simple, the [actual proof](https://eprint.iacr.org/2019/943) has become quite delicate and crafty over the years. What happened was that some colleagues -- Chen Feng at UBC and Dongning Guo at Northwestern -- identified very subtle flaws in the proof, and clever mathematical maneuvers had to be put in to fix them.  

The good news is that my coauthor [Dongning Guo](http://users.ece.northwestern.edu/~dguo/) and I have since come up with an even simpler proof! Moreover, the new proof is **almost concretely tight** for Bitcoin parameters. [The paper](https://arxiv.org/abs/2203.06357) recently won the inaugural [Chaincode Labs Bitcoin Research Prize](https://research.chaincode.com/research-prize/). It gives me an excuse to write this long overdue follow-up post on this simpler and tighter proof. I will give a high-level overview without defining a formal model. But if you are interested, the formal model is the same one as in the [previous post](https://decentralizedthoughts.github.io/2019-11-29-Analysis-Nakamoto/). 

I will start by highlighting the two main challenges in the line of work on Nakamoto consensus security proofs. First, the proof has to account for all possible attack strategies under a model, including strategies that we may have never thought about. Second, network delays make different honest nodes have different views, and that creates a lot of difficulties. In our new proof, we managed to find very simple ways to overcome both challenges.

Let us first ignore the second challenge and consider a network with zero delay. With zero delay, we can prove that a fairly simple attack strategy, *private mining with lead*, is an optimal attack strategy. Any other strategy, no matter how sophisticated, is at most as good as this one. This is the answer to the first challenge! We no longer have to worry about all possible attack strategies or some crazy strategy that no one has ever thought about. We just need to calculate the success probability of this one concrete attack, a much easier task. 

Here is a short description of the attack strategy. The attacker first tries to mine some private blocks on top of the public main chain. This part is essentially [selfish mining](https://decentralizedthoughts.github.io/2020-02-26-selfish-mining/). If the public chain catches up, the attacker releases its private chain to get those block rewards and restart private mining at the new tip of the chain. Once the target transaction shows up on the public chain, the attacker will double down and mine on its private chain forever, i.e., enter a mining race with the public chain. To connect the dots, the few private blocks the attacker got in the selfish mining part serve as a head start (called lead in the paper) for this race. The attacker wins if its private chain is ever longer than the public chain after the target transaction is finalized ($k$ blocks deep). 

Rigorously proving this strategy optimal is nontrivial and the hardest part of our paper. (The [Everything is a race](https://arxiv.org/abs/2005.10484) paper first observed this optimality but only proved it in a special case.) I encourage you to check out [our paper](https://arxiv.org/abs/2203.06357). For some quick intuition, when there is zero delay, the best an attacker can hope for is that every block it mines takes it one step closer to success and that every block mined by some honest node sets it back one step. The private mining strategy achieves exactly that. I will also note that the Bitcoin whitepaper calculated confirmation depths assuming, without proof, that a variant of this strategy is optimal.  

Now, we turn to the second challenge: network delays. Let us first ask ourselves: what is the defining feature of zero delay that enables the optimality result above? It's that all the blocks mined by honest nodes (let us call them honest blocks for short) are "aware of" each other, so they always form a chain. With network delay, this is no longer true. Honest blocks mined around the same time are unaware of each other and will fork. But here comes the key observation of our paper. If an honest block "tailgates" (mined too closely to) a previous block, we simply give it to the attacker for free; in other words, we pretend it is mined by the attacker. Now, all the remaining honest blocks are mined reasonably far apart in time and are aware of each other. 

This simple trick of giving away some blocks solves the second challenge by reducing the positive-delay case to the zero-delay case! The success probability of any attack in a network with delay is upper bounded by the success probability of the private mining with lead attack with the attacker's mining power boosted by the "tailgating" honest blocks. Furthermore, because Bitcoin's expected block internal (10 minutes) is much longer than the block propagation delay (a few seconds), the number of tailgating blocks is small, so the final result is almost tight. 

That's pretty much the entire proof. I hope you find it simple and like its simplicity. Even this simple proof took Dongning and me nine months to finish. We got stuck many times. We found and fixed many subtle flaws. To clarify, these (and previous) flaws are not results of simplicity but rather get exposed thanks to simplicity. So simplicity helps rigor. Simplicity also helps produce tight and practical results. But even without pragmatic benefits, simplicity is valuable: 
> It can scarcely be denied that the supreme goal of all theory is to make the irreducible basic elements as simple and as few as possible without having to surrender the adequate representation of a single datum of experience. -- Albert Einstein, 1933.
